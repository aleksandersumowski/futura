<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.2">
<meta name="author" content="Andrey Antukh, &lt;niwi@niwi.be&gt;">
<title>futura - building blocks for asynchronous programming in Clojure</title>
<style>
.listingblock .pygments .hll { background-color: #ffffcc }
.listingblock .pygments  { background: #f0f0f0; }
.listingblock .pygments .tok-c { color: #60a0b0; font-style: italic } /* Comment */
.listingblock .pygments .tok-err { border: 1px solid #FF0000 } /* Error */
.listingblock .pygments .tok-k { color: #007020; font-weight: bold } /* Keyword */
.listingblock .pygments .tok-o { color: #666666 } /* Operator */
.listingblock .pygments .tok-cm { color: #60a0b0; font-style: italic } /* Comment.Multiline */
.listingblock .pygments .tok-cp { color: #007020 } /* Comment.Preproc */
.listingblock .pygments .tok-c1 { color: #60a0b0; font-style: italic } /* Comment.Single */
.listingblock .pygments .tok-cs { color: #60a0b0; background-color: #fff0f0 } /* Comment.Special */
.listingblock .pygments .tok-gd { color: #A00000 } /* Generic.Deleted */
.listingblock .pygments .tok-ge { font-style: italic } /* Generic.Emph */
.listingblock .pygments .tok-gr { color: #FF0000 } /* Generic.Error */
.listingblock .pygments .tok-gh { color: #000080; font-weight: bold } /* Generic.Heading */
.listingblock .pygments .tok-gi { color: #00A000 } /* Generic.Inserted */
.listingblock .pygments .tok-go { color: #888888 } /* Generic.Output */
.listingblock .pygments .tok-gp { color: #c65d09; font-weight: bold } /* Generic.Prompt */
.listingblock .pygments .tok-gs { font-weight: bold } /* Generic.Strong */
.listingblock .pygments .tok-gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.listingblock .pygments .tok-gt { color: #0044DD } /* Generic.Traceback */
.listingblock .pygments .tok-kc { color: #007020; font-weight: bold } /* Keyword.Constant */
.listingblock .pygments .tok-kd { color: #007020; font-weight: bold } /* Keyword.Declaration */
.listingblock .pygments .tok-kn { color: #007020; font-weight: bold } /* Keyword.Namespace */
.listingblock .pygments .tok-kp { color: #007020 } /* Keyword.Pseudo */
.listingblock .pygments .tok-kr { color: #007020; font-weight: bold } /* Keyword.Reserved */
.listingblock .pygments .tok-kt { color: #902000 } /* Keyword.Type */
.listingblock .pygments .tok-m { color: #40a070 } /* Literal.Number */
.listingblock .pygments .tok-s { color: #4070a0 } /* Literal.String */
.listingblock .pygments .tok-na { color: #4070a0 } /* Name.Attribute */
.listingblock .pygments .tok-nb { color: #007020 } /* Name.Builtin */
.listingblock .pygments .tok-nc { color: #0e84b5; font-weight: bold } /* Name.Class */
.listingblock .pygments .tok-no { color: #60add5 } /* Name.Constant */
.listingblock .pygments .tok-nd { color: #555555; font-weight: bold } /* Name.Decorator */
.listingblock .pygments .tok-ni { color: #d55537; font-weight: bold } /* Name.Entity */
.listingblock .pygments .tok-ne { color: #007020 } /* Name.Exception */
.listingblock .pygments .tok-nf { color: #06287e } /* Name.Function */
.listingblock .pygments .tok-nl { color: #002070; font-weight: bold } /* Name.Label */
.listingblock .pygments .tok-nn { color: #0e84b5; font-weight: bold } /* Name.Namespace */
.listingblock .pygments .tok-nt { color: #062873; font-weight: bold } /* Name.Tag */
.listingblock .pygments .tok-nv { color: #bb60d5 } /* Name.Variable */
.listingblock .pygments .tok-ow { color: #007020; font-weight: bold } /* Operator.Word */
.listingblock .pygments .tok-w { color: #bbbbbb } /* Text.Whitespace */
.listingblock .pygments .tok-mb { color: #40a070 } /* Literal.Number.Bin */
.listingblock .pygments .tok-mf { color: #40a070 } /* Literal.Number.Float */
.listingblock .pygments .tok-mh { color: #40a070 } /* Literal.Number.Hex */
.listingblock .pygments .tok-mi { color: #40a070 } /* Literal.Number.Integer */
.listingblock .pygments .tok-mo { color: #40a070 } /* Literal.Number.Oct */
.listingblock .pygments .tok-sb { color: #4070a0 } /* Literal.String.Backtick */
.listingblock .pygments .tok-sc { color: #4070a0 } /* Literal.String.Char */
.listingblock .pygments .tok-sd { color: #4070a0; font-style: italic } /* Literal.String.Doc */
.listingblock .pygments .tok-s2 { color: #4070a0 } /* Literal.String.Double */
.listingblock .pygments .tok-se { color: #4070a0; font-weight: bold } /* Literal.String.Escape */
.listingblock .pygments .tok-sh { color: #4070a0 } /* Literal.String.Heredoc */
.listingblock .pygments .tok-si { color: #70a0d0; font-style: italic } /* Literal.String.Interpol */
.listingblock .pygments .tok-sx { color: #c65d09 } /* Literal.String.Other */
.listingblock .pygments .tok-sr { color: #235388 } /* Literal.String.Regex */
.listingblock .pygments .tok-s1 { color: #4070a0 } /* Literal.String.Single */
.listingblock .pygments .tok-ss { color: #517918 } /* Literal.String.Symbol */
.listingblock .pygments .tok-bp { color: #007020 } /* Name.Builtin.Pseudo */
.listingblock .pygments .tok-vc { color: #bb60d5 } /* Name.Variable.Class */
.listingblock .pygments .tok-vg { color: #bb60d5 } /* Name.Variable.Global */
.listingblock .pygments .tok-vi { color: #bb60d5 } /* Name.Variable.Instance */
.listingblock .pygments .tok-il { color: #40a070 } /* Literal.Number.Integer.Long */
</style>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic|Liberation+Mono:400|Roboto+Slab:400,700"/>
<link rel="stylesheet" href="https://www.niwi.nz/_assets/asciidoctor-styles/simple-red-titles/stylesheet.css"/>
</head>
<body class="article toc2 toc-left">
<div id="header">
<h1>futura - building blocks for asynchronous programming in Clojure</h1>
<div class="details">
<span id="author" class="author">Andrey Antukh, &lt;niwi@niwi.be&gt;</span><br>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_introduction">1. Introduction</a></li>
<li><a href="#_rationale">2. Rationale</a></li>
<li><a href="#_project_maturity">3. Project Maturity</a></li>
<li><a href="#_install">4. Install</a></li>
<li><a href="#_promises">5. Promises</a>
<ul class="sectlevel2">
<li><a href="#_creating_a_promise">5.1. Creating a promise.</a></li>
<li><a href="#_blocking_operations">5.2. Blocking operations</a></li>
<li><a href="#_state_checking">5.3. State checking</a></li>
<li><a href="#_promise_chaining">5.4. Promise chaining</a></li>
<li><a href="#_error_handling">5.5. Error handling</a></li>
<li><a href="#_working_with_collections">5.6. Working with collections</a></li>
</ul>
</li>
<li><a href="#_streams">6. Streams</a>
<ul class="sectlevel2">
<li><a href="#_first_contact">6.1. First contact</a></li>
<li><a href="#_source_the_publisher">6.2. Source the publisher</a></li>
<li><a href="#_composable_trasnformations">6.3. Composable trasnformations</a></li>
<li><a href="#_subscription_as_channel">6.4. Subscription as channel</a></li>
</ul>
</li>
<li><a href="#_atomics">7. Atomics</a>
<ul class="sectlevel2">
<li><a href="#_atomic_reference">7.1. Atomic Reference</a></li>
<li><a href="#_atomic_boolean">7.2. Atomic Boolean</a></li>
<li><a href="#_atomic_long">7.3. Atomic Long</a></li>
</ul>
</li>
<li><a href="#_executors">8. Executors</a></li>
<li><a href="#_faq">9. FAQ</a>
<ul class="sectlevel2">
<li><a href="#difference-with-manifold">9.1. What is the difference with manifold</a></li>
</ul>
</li>
<li><a href="#_contribute">10. Contribute</a></li>
<li><a href="#_get_the_code">11. Get the Code</a></li>
<li><a href="#_run_tests">12. Run tests</a></li>
<li><a href="#_license">13. License</a></li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_introduction"><a class="link" href="#_introduction">1. Introduction</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>The basic building blocks for concurrent, asynchronous and non blocking programming in clojure.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_rationale"><a class="link" href="#_rationale">2. Rationale</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>This project exists as consecuence of the need of good abstraction for represent eventually available
asynchronous values for the <a href="https://github.com/funcool/catacumba">catacumba project</a>.</p>
</div>
<div class="paragraph">
<p>It there already existing libraries in clojure ecosystem such as <em>manifold</em> that are well
established and intends to be a "lingua franca" for asynchronous computation results. But I think
that here there space for an alternative with different vision. For see more detailed information
about the differences with <em>manifold</em>, see <a href="#difference-with-manifold">this</a> faq entry.</p>
</div>
<div class="paragraph">
<p>The <em>futura</em> library at this moment provides three different building blocks:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Streams</strong><br>
I did not want invent yet an other streams abstraction and luckily I found
the <a href="http://www.reactive-streams.org/">reactive streams</a> initiative that has already defined
a strong and well defined contract on how the abstraction should behave and with backpressure
awareness in its core.<br>
This library uses that interfaces and provides a powerfull clojure features (like transducers) to
the good and interoperable stream abstraction.</p>
</li>
<li>
<p><strong>Promises</strong><br>
With promises happens something similar, but in this case JDK8 comes with good implementation with
wrong name: <code>CompletableFuture</code>. This library provides a promise abstraction primitive build on top
of jdk8 completable futures implementation and implements the monadic protocols of cats library that
allows it to play in the monadic composition using generic syntactic abstractions like haskell
like <code>do syntax</code>.</p>
</li>
<li>
<p><strong>Atomics</strong><br>
Additionally to the mentioned abstractions, this library provides an lighweight clojure friendly
syntax for working with JDK Atomic types and references that are often used as concurrency primitives
in the streams implementation.</p>
</li>
<li>
<p><strong>Executors</strong><br>
A clojure friendly abstraction for the java/jvm executors.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_project_maturity"><a class="link" href="#_project_maturity">3. Project Maturity</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Since <em>futura</em> is a young project there may be some API breakage.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_install"><a class="link" href="#_install">4. Install</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>The simplest way to use <em>futura</em> library in a ClojureScript project is by including
it as a dependency:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">[</span><span class="tok-nv">funcool/futura</span> <span class="tok-s">&quot;0.3.0&quot;</span><span class="tok-p">]</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_promises"><a class="link" href="#_promises">5. Promises</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Is the abstraction that represents the result of an asynchronous operation that will be eventually
available.</p>
</div>
<div class="paragraph">
<p>Clojure comes with a builtin promise abstraction but it is designed only blocking operations, and in
our circumstances it is very limited approach. The <em>futura</em>'s promise abstraction uses the jdk8
completable future as underlying implementation and all promises can be easily coerced to
jdk future or completable future.</p>
</div>
<div class="paragraph">
<p>The promise consists in a container that eventually will contain a value with builtin support for
error handling. So the promise has three different states:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>pending</code>: means that the promise does not contains any value.</p>
</li>
<li>
<p><code>resolved</code>: means that the promise contains a value.</p>
</li>
<li>
<p><code>rejected</code>: means thet the promise contains an error.</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_creating_a_promise"><a class="link" href="#_creating_a_promise">5.1. Creating a promise.</a></h3>
<div class="paragraph">
<p>It there several different ways to create a promise in <em>futura</em> library. You can create it inmediatelly
resolved with initial value, inmediatelly rejected with some exception.</p>
</div>
<div class="paragraph">
<p>Let start with a basic example using the commonly known promise delivering in clojure:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">futura.promise</span> <span class="tok-ss">:as</span> <span class="tok-nv">p</span><span class="tok-p">])</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nb">pr </span><span class="tok-p">(</span><span class="tok-nf">p/promise</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">future</span>
  <span class="tok-p">(</span><span class="tok-nf">Thread/sleep</span> <span class="tok-mi">200</span><span class="tok-p">)</span>
  <span class="tok-p">(</span><span class="tok-nf">p/deliver</span> <span class="tok-nb">pr </span><span class="tok-mi">20</span><span class="tok-p">))]</span>

<span class="tok-p">(</span><span class="tok-nf">p/then</span> <span class="tok-nb">pr </span><span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">v</span><span class="tok-p">]</span>
             <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-nv">v</span><span class="tok-p">)))</span>

<span class="tok-c1">;; After 200ms it will print `20`</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>An other way to create a promise is using a factory function that can resolve or reject
promise in asynchrnous way. If you are familiar with javascript promises, you will found
that very similar:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nb">pr </span><span class="tok-p">(</span><span class="tok-nf">p/promise</span>
          <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">deliver</span><span class="tok-p">]</span>
            <span class="tok-p">(</span><span class="tok-nf">deliver</span> <span class="tok-mi">1</span><span class="tok-p">))))</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_blocking_operations"><a class="link" href="#_blocking_operations">5.2. Blocking operations</a></h3>
<div class="paragraph">
<p>The <em>futura</em>'s promises can be used as drop in replacement for clojure promises, because them offers
also blocking operations:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-o">@</span><span class="tok-nv">pr</span>
<span class="tok-c1">;; =&gt; 1</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>If you try to deref a promise that is rejected, the exception will be rereaised in the
calling thread.</p>
</div>
</div>
<div class="sect2">
<h3 id="_state_checking"><a class="link" href="#_state_checking">5.3. State checking</a></h3>
<div class="paragraph">
<p><em>futura</em> provides useful predicates that will allow check the state of a promise in any time.</p>
</div>
<div class="paragraph">
<p>Let see some examples:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nb">pr </span><span class="tok-p">(</span><span class="tok-nf">p/promise</span> <span class="tok-mi">2</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">p/promise?</span> <span class="tok-nv">pr</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; true</span>

<span class="tok-p">(</span><span class="tok-nf">p/pending?</span> <span class="tok-nv">pr</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; false</span>

<span class="tok-p">(</span><span class="tok-nf">p/resolved?</span> <span class="tok-nv">pr</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; true</span>

<span class="tok-p">(</span><span class="tok-nf">p/rejected?</span> <span class="tok-nv">pr</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; false</span>

<span class="tok-p">(</span><span class="tok-nf">p/done?</span> <span class="tok-nv">pr</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; true</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>done?</code> predicate checks if a promise is fullfiled, independently if is resolved or rejected.</p>
</div>
</div>
<div class="sect2">
<h3 id="_promise_chaining"><a class="link" href="#_promise_chaining">5.4. Promise chaining</a></h3>
<div class="paragraph">
<p><em>Futura</em> also offers powerful chaining methods for allow easy compose async computations. In
previous examples we have seen <code>then</code> function, let see an other more complex example using it:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nb">pr </span><span class="tok-p">(</span><span class="tok-nb">-&gt; </span><span class="tok-p">(</span><span class="tok-nf">p/promise</span> <span class="tok-mi">2</span><span class="tok-p">)</span>
            <span class="tok-p">(</span><span class="tok-nf">p/then</span> <span class="tok-nv">inc</span><span class="tok-p">)</span>
            <span class="tok-p">(</span><span class="tok-nf">p/then</span> <span class="tok-nv">inc</span><span class="tok-p">)))</span>

<span class="tok-p">(</span><span class="tok-nf">p/then</span> <span class="tok-nb">pr </span><span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">v</span><span class="tok-p">]</span>
             <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-nv">v</span><span class="tok-p">)))</span>

<span class="tok-c1">;; It will print 4.</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_error_handling"><a class="link" href="#_error_handling">5.5. Error handling</a></h3>
<div class="paragraph">
<p>It also exposes a chain method for error handling:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nb">pr </span><span class="tok-p">(</span><span class="tok-nb">-&gt; </span><span class="tok-p">(</span><span class="tok-nf">p/promise</span> <span class="tok-mi">2</span><span class="tok-p">)</span>
            <span class="tok-p">(</span><span class="tok-nf">p/then</span> <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">v</span><span class="tok-p">]</span> <span class="tok-p">(</span><span class="tok-nf">throw</span> <span class="tok-p">(</span><span class="tok-nf">ex-info</span> <span class="tok-s">&quot;foobar&quot;</span> <span class="tok-p">{}))))))</span>

<span class="tok-p">(</span><span class="tok-nf">p/catch</span> <span class="tok-nb">pr </span><span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">error</span><span class="tok-p">]</span>
              <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;Error:&quot;</span> <span class="tok-p">(</span><span class="tok-nf">.getMessage</span> <span class="tok-nv">error</span><span class="tok-p">))))</span>
<span class="tok-c1">;; Will print something like &quot;Error: foobar&quot;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>catch</code> chain function also return a promise. Promise that will be resolved or rejected
depending on that will happen inside the catch handler.</p>
</div>
</div>
<div class="sect2">
<h3 id="_working_with_collections"><a class="link" href="#_working_with_collections">5.6. Working with collections</a></h3>
<div class="paragraph">
<p>In some circumstances you will want wait a completion of few promises at same time, and <em>futura</em>
also provides helpers for that:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-o">@</span><span class="tok-p">(</span><span class="tok-nf">p/all</span> <span class="tok-p">[(</span><span class="tok-nf">p/promise</span> <span class="tok-mi">1</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-nf">p/promise</span> <span class="tok-mi">2</span><span class="tok-p">)])</span>
<span class="tok-c1">;; =&gt; [1 2]</span>

<span class="tok-o">@</span><span class="tok-p">(</span><span class="tok-nf">p/any</span> <span class="tok-p">[(</span><span class="tok-nf">p/promise</span> <span class="tok-mi">1</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-nf">p/promise</span> <span class="tok-p">(</span><span class="tok-nf">ex-info</span> <span class="tok-s">&quot;error&quot;</span> <span class="tok-p">{}))])</span>
<span class="tok-c1">;; =&gt; 1</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_streams"><a class="link" href="#_streams">6. Streams</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>The streams in <em>futura</em> library are governed by the
<a href="http://www.reactive-streams.org/">reactive streams</a> iniciative and its default interfaces
for the jvm languages. Additionally, it comes with support for the the powerful clojure&#8217;s features as
transducers and sequence abstractions and with great interoprability with existing clojure libraries.</p>
</div>
<div class="paragraph">
<p>In summary, is a reactive-streams implementation on top of clojure abstractions and works as
intermediary between clojure and the java world.</p>
</div>
<div class="paragraph">
<p>The reactive streams has four participants, but in the clojure part we only need one: the Publisher.</p>
</div>
<div class="sect2">
<h3 id="_first_contact"><a class="link" href="#_first_contact">6.1. First contact</a></h3>
<div class="paragraph">
<p>The <em>futura</em>'s streams api is really very simple. It consists in ver few functions.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s go to create our first publisher:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">futura.stream</span> <span class="tok-ss">:as</span> <span class="tok-nv">stream</span><span class="tok-p">])</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">s</span> <span class="tok-p">(</span><span class="tok-nf">stream/publisher</span><span class="tok-p">))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>publisher</code> function without additional parameters creates a empty, and unbuffered publisher. Now
you can put the items to the using the <code>put!</code> function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">prm</span> <span class="tok-p">(</span><span class="tok-nf">stream/put!</span> <span class="tok-nv">s</span> <span class="tok-mi">1</span><span class="tok-p">))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The return value of the <code>put!</code> function is a promise that will be resolved to true when the value is
accepted by the publisher. And in case of the unbuffered publisher it will happens when one subscription
will request a value.</p>
</div>
<div class="paragraph">
<p>And finally, for obtain values from the publisher, you should create a subscription:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nb">with-open </span><span class="tok-p">[</span><span class="tok-nv">sub</span> <span class="tok-p">(</span><span class="tok-nf">s/subscribe</span> <span class="tok-nv">s</span><span class="tok-p">)]</span>
  <span class="tok-p">(</span><span class="tok-nf">s/take!</span> <span class="tok-nv">s</span><span class="tok-p">))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The return value of <code>take!</code> function is also a promise and will be resolved with a value when the first
one will be available.</p>
</div>
<div class="paragraph">
<p>Take care that the <code>subscribe</code> function it is not analogous to the <code>.subscribe</code> method of the publisher.
Instead of creating opaque object that acts as relation betwen the publisher and the subscriber, the
<code>subscribe</code> function creates a open object that does not has direct relation with any subscriber.</p>
</div>
<div class="paragraph">
<p>Obviously, behind the schenes the <code>subscribe</code> function uses the publishers <code>.subscribe</code> method. So the
publisher implementation is completelly interopreable with other third party libraries and the java world.</p>
</div>
<div class="paragraph">
<p>This subscription strategy has some advantages over the purposed by the reactive-streams, because you can
treat it like a subscription stream. It implements convenient interfaces for the ability to treat the
subscription like a clojure sequence, java iterable or even core.async channel.</p>
</div>
<div class="paragraph">
<p>You should known that everything in this implementation is lazy. Creating subscription does not
automatically request all items from publisher. A subscription will only request a item to the publisher
when you are request it.</p>
</div>
<div class="paragraph">
<p>Behind the scenes, publisher and subscription are implemented using <em>core.async</em>, so the nil values
are does not allowed and represent that the publisher or the subscription is closed. The subscription
as you can observe implements the <code>.close()</code> method that allows use it with <code>with-open</code> macro, but take
care, the publisher can end early and subscrion will be closed also before with-open calls the
<code>.close()</code> method.</p>
</div>
</div>
<div class="sect2">
<h3 id="_source_the_publisher"><a class="link" href="#_source_the_publisher">6.2. Source the publisher</a></h3>
<div class="paragraph">
<p>As we said previously, the real purpose of this abstraction is using it as connection with java world,
surelly if you are clojure only user you may want use <em>core.async</em> or <em>manifold</em> directly without
additional layer.</p>
</div>
<div class="paragraph">
<p>In fact, <em>futura</em> is actually used by <em>catacumba</em> for comunicating asyncronous streams with
ratpack/netty. This abstraction is choiced because it has support for backpressure that is very
important in asynchronous network applications.</p>
</div>
<div class="paragraph">
<p>But for use it as a intermediary layer with third party libraries you should will be able create
publisher from the existing abstractions in clojure. Now, let se how you can do it:</p>
</div>
<div class="listingblock">
<div class="title">Example creating a publisher instance from any object that implements <code>Iterable</code>:</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">pub</span> <span class="tok-p">(</span><span class="tok-nf">p/publisher</span> <span class="tok-p">(</span><span class="tok-nb">take </span><span class="tok-mi">5</span> <span class="tok-p">(</span><span class="tok-nb">iterate inc </span><span class="tok-mi">1</span><span class="tok-p">))))</span>

<span class="tok-p">(</span><span class="tok-nb">into </span><span class="tok-p">[]</span> <span class="tok-nv">pub</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; [1 2 3 4 5]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can observe the previous example, you can see that the publisher can be easily converted
to sequence. That happens because publisher implements the clojure&#8217;s <code>Seqable</code> interface that behind
the scenes uses a subscription and blocking access to all items until the subscription is closed.</p>
</div>
<div class="paragraph">
<p>So, you can create a publisher from this kind of abstractions: <strong>promise</strong>, jdk8 <strong>completable future</strong>,
manifold <strong>deferred</strong>, manifold <strong>stream</strong>, <strong>sequences</strong> and <strong>iterables</strong>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_composable_trasnformations"><a class="link" href="#_composable_trasnformations">6.3. Composable trasnformations</a></h3>
<div class="paragraph">
<p>Additionally to the previously mentioned abstractions, you can create a publisher from another
publisher using the <code>transform</code> function. This kind of composition allows you attach a transducer
for apply some kind of transformations to the stream values.</p>
</div>
<div class="paragraph">
<p>Take care de some implementation detail: the transducer is applied for subscriptions, not for the
publisher. So, if you use some kind of <code>(take N)</code> transducer with possible infinite publisher, it will
cause that each subscription will be closed after <code>N</code> items but the publisher will remain active
accepting new subscriptions.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">pub</span> <span class="tok-p">(</span><span class="tok-nf">-&gt;&gt;</span> <span class="tok-p">(</span><span class="tok-nf">p/publisher</span> <span class="tok-p">(</span><span class="tok-nb">take </span><span class="tok-mi">5</span> <span class="tok-p">(</span><span class="tok-nb">iterate inc </span><span class="tok-mi">1</span><span class="tok-p">)))</span>
              <span class="tok-p">(</span><span class="tok-nf">p/transform</span> <span class="tok-p">(</span><span class="tok-nb">map </span><span class="tok-nv">inc</span><span class="tok-p">))))</span>

<span class="tok-p">(</span><span class="tok-nb">into </span><span class="tok-p">[]</span> <span class="tok-nv">pub</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; [2 3 4 5 6]</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_subscription_as_channel"><a class="link" href="#_subscription_as_channel">6.4. Subscription as channel</a></h3>
<div class="paragraph">
<p>One interesting thing is that open subscriptions can be used as channels so them are fully compatible
for usage in <em>core.async</em> go block like any other channel:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">clojure.core.async</span> <span class="tok-ss">:refer</span> <span class="tok-p">[</span><span class="tok-nv">&lt;!</span> <span class="tok-nv">go-loop</span><span class="tok-p">]])</span>

<span class="tok-p">(</span><span class="tok-nb">with-open </span><span class="tok-p">[</span><span class="tok-nv">sub</span> <span class="tok-p">(</span><span class="tok-nf">s/subscribe</span> <span class="tok-nv">s</span><span class="tok-p">)]</span>
  <span class="tok-p">(</span><span class="tok-nf">go-loop</span> <span class="tok-p">[]</span>
    <span class="tok-p">(</span><span class="tok-nb">when-let </span><span class="tok-p">[</span><span class="tok-nv">value</span> <span class="tok-p">(</span><span class="tok-nf">&lt;!</span> <span class="tok-nv">sub</span><span class="tok-p">)]</span>
      <span class="tok-p">(</span><span class="tok-nf">do-something</span> <span class="tok-nv">value</span><span class="tok-p">)</span>
      <span class="tok-p">(</span><span class="tok-nf">recur</span><span class="tok-p">))))</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_atomics"><a class="link" href="#_atomics">7. Atomics</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>This is a simple clojure friendly syntax and lightweight abstraction built on top of clojure&#8217;s protocols
for treat with JDK atomic types and reference types.</p>
</div>
<div class="paragraph">
<p>This is a low level, side effecting primitive and should be used only when you are really known that
are you doing. If you do not know if you should use it or not, prefer using standard clojure primitives
such as atom, ref, and agents.</p>
</div>
<div class="sect2">
<h3 id="_atomic_reference"><a class="link" href="#_atomic_reference">7.1. Atomic Reference</a></h3>
<div class="paragraph">
<p>The atomic reference privides a lock-free, thread safe object reference container. The real purpose
of this type is store a reference to an arbitrary object and will be able mutate it in a thread
safe, lock-fre way.</p>
</div>
<div class="sect3">
<h4 id="_creating_an_atomic_reference"><a class="link" href="#_creating_an_atomic_reference">7.1.1. Creating an atomic reference</a></h4>
<div class="paragraph">
<p>The atomic reference can be created with <code>ref</code> function from the <code>futura.atomic</code> namespace:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">futura.atomic</span> <span class="tok-ss">:as</span> <span class="tok-nv">atomic</span><span class="tok-p">])</span>

<span class="tok-p">(</span><span class="tok-nf">atomic/ref</span> <span class="tok-ss">:foo</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; #object[futura.atomic.AtomicRef 0x5e42bd13 {:status :ready, :val :foo}]</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_get_and_set_values"><a class="link" href="#_get_and_set_values">7.1.2. Get and set values</a></h4>
<div class="paragraph">
<p>The atomic reference provides the standard way to set or get values using <code>get</code> and <code>set!</code> functions:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">atomic/set!</span> <span class="tok-nv">myref</span> <span class="tok-ss">:baz</span><span class="tok-p">)</span>

<span class="tok-p">(</span><span class="tok-nf">atomic/get</span> <span class="tok-nv">myref</span><span class="tok-p">)</span>
<span class="tok-c1">;; :baz</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Additionally it also implements the clojure <code>IDeref</code> interface for make it easy use with <code>@</code> reader
macro or <code>deref</code> function:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">myref</span> <span class="tok-p">(</span><span class="tok-nf">atomic/ref</span> <span class="tok-ss">:foo</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nb">deref </span><span class="tok-nv">myref</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; :foo</span>

<span class="tok-o">@</span><span class="tok-nv">myref</span>
<span class="tok-c1">;; =&gt; :foo</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_special_operations"><a class="link" href="#_special_operations">7.1.3. Special operations</a></h4>
<div class="paragraph">
<p>The atomic types usually offers some special operations, and this one is not an exception. The atomic
refernce allow CAS operations (compare and set):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">atomic/compare-and-set!</span> <span class="tok-nv">myref</span> <span class="tok-ss">:baz</span> <span class="tok-ss">:foobar</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; false</span>

<span class="tok-p">(</span><span class="tok-nf">atomic/compare-and-set!</span> <span class="tok-nv">myref</span> <span class="tok-ss">:foo</span> <span class="tok-ss">:bar</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; true</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>And the "get and set" operation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">atomic/get-and-set!</span> <span class="tok-nv">myref</span> <span class="tok-ss">:foo</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; :bar</span>

<span class="tok-o">@</span><span class="tok-nv">myref</span>
<span class="tok-c1">;; =&gt; :foo</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Additionaly it provides a way to set a value in some kind of "asynchronously" way. But take care, this
method to set the value does not guarrantee that the change is visible instantly to all threads:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">atomic/eventually-set!</span> <span class="tok-nv">myref</span> <span class="tok-ss">:foobar</span><span class="tok-p">)</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_atomic_boolean"><a class="link" href="#_atomic_boolean">7.2. Atomic Boolean</a></h3>
<div class="paragraph">
<p>This is a specialized version of Atomic Reference that is higtly optimized for boolean values. It
has the same operations and implements the same abstractions that previously explained atomic ref.</p>
</div>
<div class="paragraph">
<p>You can create an atomic boolean using <code>boolean</code> function from <code>futura.atomic</code> namespace:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">atomic/boolean</span> <span class="tok-nv">false</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; #object[futura.atomic.AtomicBoolean 0x393bbfce {:status :ready, :val false}]</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_atomic_long"><a class="link" href="#_atomic_long">7.3. Atomic Long</a></h3>
<div class="paragraph">
<p>This is a specialized version of Atomic Reference that is highly optimized for numeric operations
with longs. It has the same operations and implements the same abstractions that previously explained
<code>ref</code> and <code>boolean</code> atomic types.</p>
</div>
<div class="paragraph">
<p>But additionally implements a complementary abstraction that brings some powerfull operations
that only fits for numeric types, such as atomic counters and similars.</p>
</div>
<div class="paragraph">
<p>You can create an atomic long using <code>long</code> function from <code>futura.atomic</code> namespace:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">atomic/long</span> <span class="tok-mi">0</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; #object[futura.atomic.AtomicLong 0x393bbfce {:status :ready, :val 0}]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Here some examples using the functions defined for numeric atomic types, such as
"get and increment/decrement" operations:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">mylong</span> <span class="tok-p">(</span><span class="tok-nf">atomic/long</span> <span class="tok-mi">0</span><span class="tok-p">))</span>

<span class="tok-p">(</span><span class="tok-nf">atomic/get-and-inc!</span> <span class="tok-nv">mylong</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 0</span>

<span class="tok-p">(</span><span class="tok-nf">atomic/get-and-dec!</span> <span class="tok-nv">mylong</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 1</span>

<span class="tok-o">@</span><span class="tok-nv">mylong</span>
<span class="tok-c1">;; =&gt; 0</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>And optionally you can increment it with user specified delta:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">atomic/get-and-add!</span> <span class="tok-nv">mylong</span> <span class="tok-mi">10</span><span class="tok-p">)</span>
<span class="tok-c1">;; =&gt; 0</span>

<span class="tok-o">@</span><span class="tok-nv">mylong</span>
<span class="tok-c1">;; =&gt; 10</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_executors"><a class="link" href="#_executors">8. Executors</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>This is a simple clojure friendly syntax and lightweight abstraction for the jvm executors.</p>
</div>
<div class="paragraph">
<p>It there two kind of operations you can do with futura executor api:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Execute a function in an executor.</p>
</li>
<li>
<p>Execute a task in an executor and wait a result of that operation using promises.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>So, the first operation consists just execute a clojure function in other thread:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">futura.executor</span> <span class="tok-ss">:as</span> <span class="tok-nv">exec</span><span class="tok-p">])</span>

<span class="tok-p">(</span><span class="tok-nf">exec/execute</span> <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[]</span>
                <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;hello world&quot;</span><span class="tok-p">)))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>And the second one, consists in execute some (maybe) blocking code in other thead
and wait the result using the promise abstraction:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">futura.executor</span> <span class="tok-ss">:as</span> <span class="tok-nv">exec</span><span class="tok-p">])</span>
<span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">futura.promise</span> <span class="tok-ss">:as</span> <span class="tok-nv">p</span><span class="tok-p">])</span>

<span class="tok-p">(</span><span class="tok-k">def </span><span class="tok-nv">prom</span> <span class="tok-p">(</span><span class="tok-nf">exec/submit</span> <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[]</span>
                         <span class="tok-p">(</span><span class="tok-nf">Thread/sleep</span> <span class="tok-mi">2000</span><span class="tok-p">)</span>
                         <span class="tok-p">(</span><span class="tok-nb">+ </span><span class="tok-mi">1</span> <span class="tok-mi">2</span><span class="tok-p">))))</span>

<span class="tok-p">(</span><span class="tok-nf">p/then</span> <span class="tok-nv">prom</span> <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[</span><span class="tok-nv">result</span><span class="tok-p">]</span>
               <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;Result:&quot;</span> <span class="tok-nv">result</span><span class="tok-p">)))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The two explained functions are multiarity and both them accepts an additional argument
for specify a user provided executor instane. So the first example is identical a this one:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="clojure"><span class="tok-p">(</span><span class="tok-nf">require</span> <span class="tok-o">&#39;</span><span class="tok-p">[</span><span class="tok-nv">futura.executor</span> <span class="tok-ss">:as</span> <span class="tok-nv">exec</span><span class="tok-p">])</span>

<span class="tok-p">(</span><span class="tok-nf">exec/execute</span> <span class="tok-nv">exec/*default*</span> <span class="tok-p">(</span><span class="tok-k">fn </span><span class="tok-p">[]</span>
                               <span class="tok-p">(</span><span class="tok-nb">println </span><span class="tok-s">&quot;hello world&quot;</span><span class="tok-p">)))</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_faq"><a class="link" href="#_faq">9. FAQ</a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="difference-with-manifold"><a class="link" href="#difference-with-manifold">9.1. What is the difference with manifold</a></h3>
<div class="paragraph">
<p>Both libraries offers similar abstractions, <em>futura</em> offers promises and streams and <em>manifold</em> offers
deferreds and streams. The main difference of this libraries is clearly philosoficaly:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>manifold</em> build own abstraction for work with streams, <em>futura</em> uses an existing and interoprable
abstraction.</p>
</li>
<li>
<p><em>manifold</em> implements its own defferred, <em>futura</em> uses the already one defined in jdk8 (completable future).</p>
</li>
<li>
<p><em>manifold</em> raises own syntax abstraction (<code>let-flow</code> and similars), <em>futura</em> implements an existing
monad abstraction from <a href="https://github.com/funcool/cats">cats library</a> that alread offers generic
let like syntax that serves for compose asynchronous computations that looks sync.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <em>futura</em> library obviosly is less mature that <em>manifold</em> because of obvios reasons that <em>manifold</em>
exists some time ago.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_contribute"><a class="link" href="#_contribute">10. Contribute</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>futura</strong> unlike Clojure and other Clojure contrib libs, does not have many
restrictions for contributions. Just open a issue or pull request.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_get_the_code"><a class="link" href="#_get_the_code">11. Get the Code</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p><em>futura</em> is open source and can be found on <a href="https://github.com/funcool/futura">github</a>.</p>
</div>
<div class="paragraph">
<p>You can clone the public repository with this command:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="text">git clone https://github.com/funcool/futura</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_run_tests"><a class="link" href="#_run_tests">12. Run tests</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>For run tests just execute this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="text">lein test</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_license"><a class="link" href="#_license">13. License</a></h2>
<div class="sectionbody">
<div class="paragraph">
<p><em>futura</em> is licensed under BSD (2-Clause) license:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>Copyright (c) 2015 Andrey Antukh &lt;niwi@niwi.be&gt;

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</pre>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2015-06-23 18:29:05 EEST
</div>
</div>
</body>
</html>